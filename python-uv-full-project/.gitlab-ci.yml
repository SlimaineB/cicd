stages: [validate, test, security, build, scan_image, package]

variables:
  PY_VERSION: "3.12"
  UV_CACHE_DIR: "/root/.cache/uv"
  AWS_REGION: "eu-west-1"         # ⚠️ Ajustez
  AWS_ACCOUNT_ID: "123456789012"   # ⚠️ Ajustez
  ECR_REPOSITORY: "$CI_PROJECT_PATH_SLUG"
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"
  IMAGE_URI: "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG"
  KANIKO_CACHE_ENABLED: "true"
  KANIKO_CACHE_REPO: "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:cache"
  # Trivy: seuil de gravité
  TRIVY_SEVERITY: "HIGH,CRITICAL"

# Override for gitlabci-local
.local:
  variables:
    KANIKO_CACHE_ENABLED: "false"
    KANIKO_CACHE_REPO: ""


.default_rules: &default_rules
  rules:
    - if: "$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS"
      when: on_success
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
      when: on_success

.cache_uv: &cache_uv
  cache:
    key: "uv-${CI_COMMIT_REF_SLUG}"
    paths:
    - ".venv/"
    - ".uv/"
    - "${UV_CACHE_DIR}/"
    policy: pull-push

# ------------------------------
#  VALIDATE
# ------------------------------
validate:ruff:
  stage: validate
  image: "ghcr.io/astral-sh/uv:python${PY_VERSION}-bookworm"
  <<: *default_rules
  <<: *cache_uv
  script:
    - uv --version
    - uv sync --dev
    - uv run ruff check .

validate:pyproject:
  stage: validate
  image: "ghcr.io/astral-sh/uv:python${PY_VERSION}-bookworm"
  <<: *default_rules
  script:
    - test -f pyproject.toml || (echo "pyproject.toml manquant" && exit 1)

# ------------------------------
#  TESTS + COVERAGE
# ------------------------------
unit-tests:
  stage: test
  image: "ghcr.io/astral-sh/uv:python${PY_VERSION}-bookworm"
  <<: *default_rules
  <<: *cache_uv
  artifacts:
    when: always
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths: [ coverage.xml ]
    expire_in: 7 days
  script:
    - uv sync --dev --frozen || uv sync --dev
    - uv run pytest -q --maxfail=1 --disable-warnings --cov=. --cov-report=term-missing --cov-report=xml:coverage.xml --junitxml=junit.xml
  coverage: '/^TOTAL\s+\d+\s+\d+\s+\d+\s+(\d+%)/'

# ------------------------------
#  SÉCURITÉ (SAST / Dépendances / Secrets)
# ------------------------------
security:bandit:
  stage: security
  image: "ghcr.io/astral-sh/uv:python${PY_VERSION}-bookworm"
  <<: *default_rules
  script:
    - uv sync --dev
    - uv run bandit -q -r app -c pyproject.toml -f json -o bandit.json || (echo "Bandit findings" && exit 1)
  artifacts:
    when: always
    paths: [ bandit.json ]
    expire_in: 7 days

security:deps:
  stage: security
  image: "ghcr.io/astral-sh/uv:python${PY_VERSION}-bookworm"
  <<: *default_rules
  script:
    - uv --version
    - uv export --format=requirements.txt > requirements.txt
    - uv run pip-audit -r requirements.txt --progress-spinner=off --format json -o pip-audit.json || (echo "Vuln deps" && exit 1)
  artifacts:
    when: always
    paths: [ pip-audit.json, requirements.txt ]
    expire_in: 7 days

security:secrets:
  stage: security
  image: alpine:latest
  <<: *default_rules
  variables:
    SCAN_PATH: "." # Set the relative path in the repo to scan
  before_script:
    - apk add --no-cache git curl jq
    - curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
  script:
    - trufflehog filesystem "$SCAN_PATH" --only-verified --fail --json | jq | tee trufflehog.json
    - test ! -s trufflehog.json || (echo "Secrets détectés" && exit 1)
  artifacts:
    when: always
    paths: [ trufflehog.json ]
    expire_in: 7 days

# ------------------------------
#  BUILD (image tar pour scan)
# ------------------------------
build:image-tar:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: "/kaniko/.docker"
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/Dockerfile" --no-push --tarPath "$CI_PROJECT_DIR/image.tar" --cache="$KANIKO_CACHE_ENABLED" --cache-repo "$KANIKO_CACHE_REPO" --snapshot-mode=redo --use-new-run --single-snapshot
  artifacts:
    paths: [ image.tar ]
    expire_in: 1 day
  rules:
    - if: "$CI_COMMIT_BRANCH"

# ------------------------------
#  SCAN IMAGE (Trivy) — blocant sur HIGH/CRITICAL
# ------------------------------
scan:image:
  stage: scan_image
  needs: [build:image-tar]
  image: aquasec/trivy:latest
  script:
    - trivy --version
    - trivy image --input image.tar --severity $TRIVY_SEVERITY --exit-code 1 --format json -o trivy.json
  artifacts:
    when: always
    paths: [ trivy.json ]
    expire_in: 7 days

# ------------------------------
#  PRÉPARE AUTH ECR (OIDC ou Access Keys)
# ------------------------------
prepare:ecr-docker-config:
  stage: package
  image: amazon/aws-cli:2
  needs: [scan:image]
  script:
    - mkdir -p .docker .aws
    # OIDC (recommandé)
    - |
      if [ -n "$AWS_ROLE_TO_ASSUME" ]; then
        echo "AssumeRoleWithWebIdentity via OIDC..."
        aws sts assume-role-with-web-identity \
          --role-arn "$AWS_ROLE_TO_ASSUME" \
          --role-session-name "gitlab-oidc-$CI_JOB_ID" \
          --web-identity-token "$CI_JOB_JWT_V2" \
          --duration-seconds 3600 > /tmp/creds.json
        export AWS_ACCESS_KEY_ID=$(jq -r .Credentials.AccessKeyId /tmp/creds.json)
        export AWS_SECRET_ACCESS_KEY=$(jq -r .Credentials.SecretAccessKey /tmp/creds.json)
        export AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken /tmp/creds.json)
      fi
    # Fallback: Access Keys
    - |
      if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
        echo "ERROR: Fournissez AWS_ROLE_TO_ASSUME (OIDC) ou des Access Keys" && exit 1
      fi
    - aws configure set region "$AWS_REGION"
    - PASS=$(aws ecr get-login-password --region "$AWS_REGION")
    - AUTH=$(printf "AWS:%s" "$PASS" | base64 -w0)
    - |
      cat > .docker/config.json <<EOF
      {"auths": {"$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com": {"auth": "$AUTH"}}}
      EOF
  artifacts:
    paths: [ .docker/config.json ]
    expire_in: 1 hour

# ------------------------------
#  PUSH ECR (Kaniko, avec cache)
# ------------------------------
package:image-kaniko:
  stage: package
  needs: [prepare:ecr-docker-config]
  image:
    name: gcr.io/kaniko-project/executor:latest
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: "/kaniko/.docker"
  script:
    - mkdir -p /kaniko/.docker
    - cp .docker/config.json /kaniko/.docker/config.json
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/Dockerfile" --destination "$IMAGE_URI" --cache=true --cache-repo "$KANIKO_CACHE_REPO" --snapshot-mode=redo --use-new-run --single-snapshot
  rules:
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH" # push auto sur la branche par défaut
      when: on_success
    - if: "$CI_COMMIT_TAG"                           # push sur tag = version
      variables: { IMAGE_TAG: "$CI_COMMIT_TAG" }
      when: on_success
